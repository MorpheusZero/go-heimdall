// Package heimdall implements utility functions for managing database
// migrations for an application.
//
// The heimdall package only works with postgres databases currently.
package heimdall

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v5"
	"log"
	"os"
	"path/filepath"
)

// Heimdall is The main instance that will handle running the database migrations.
type Heimdall struct {
	migrationTableName          string    // The name of the table that Heimdall will create in your database to store information about the migration history
	migrationFilesDirectoryPath string    // The relative path of the directory that holds all of your .sql files that should be run.
	db                          *pgx.Conn // A reference to the active database connection
	verbose                     bool      // If TRUE, will output more logging information about the migrations being ran
}

// migrationFile represents a SQL migration file in your specified migrations directory.
type migrationFile struct {
	Filename string // The name of the file on disk
	SQL      string // The actual SQL content that will be run on the server
}

// NewHeimdall Creates a new Heimdall instance.
func NewHeimdall(connectionString string, migrationTableName string, migrationFilesDirectoryPath string, verbose bool) *Heimdall {
	db := newDatabaseConnection(connectionString)
	return &Heimdall{db: db, migrationTableName: migrationTableName, migrationFilesDirectoryPath: migrationFilesDirectoryPath, verbose: verbose}
}

// newDatabaseConnection Handles creating the database connection and setting some values that we will use.
func newDatabaseConnection(connectionString string) *pgx.Conn {
	conn, err := pgx.Connect(context.Background(), connectionString)
	if err != nil {
		log.Panicln(err)
	}
	return conn
}

// RunMigrations Runs the entire migration process.
// This is the only public function that is exposed by Heimdall for running everything.
func (h *Heimdall) RunMigrations() error {
	err := initializeMigrationHistoryTable(h.db, h.migrationTableName)
	if err != nil {
		log.Println(err)
		log.Fatalln("an error occurred when attempting to create the migrations history table")
		return err
	}
	migrationFiles, err := getAllMigrationFiles(h.migrationFilesDirectoryPath)
	if err != nil {
		log.Println(err)
		log.Fatalln("an error occurred when attempting to retrieve all migration files from the disk")
		return err
	}
	migrationsInDB, err := getMigrationsInDB(h.db, h.migrationTableName)
	if err != nil {
		log.Println(err)
		log.Fatalln("an error occurred when attempting to retrieve all migration history from the db")
		return err
	}
	migrationsToRun := compareMigrationsToRun(migrationFiles, migrationsInDB)
	err = performMigrations(migrationsToRun, h.db, h.migrationTableName, h.verbose)
	if err != nil {
		log.Println(err)
		log.Fatalln("an error occurred when attempting to perform the migrations")
		return err
	}
	return nil
}

// initializeMigrationHistoryTable will attempt to create the migrations history table if it does not exist.
func initializeMigrationHistoryTable(db *pgx.Conn, migrationTableName string) error {
	sql := fmt.Sprintf(`
		CREATE TABLE IF NOT EXISTS "%s" (
		"id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		"created_at" timestamp DEFAULT (now()),
		"filename" text
		);
	`, migrationTableName)
	_, err := db.Exec(context.Background(), sql)
	if err != nil {
		return err
	}
	return nil
}

// getAllMigrationFiles will read the given directory path to load all .sql files and read their contents.
func getAllMigrationFiles(migrationFilesDirectoryPath string) ([]migrationFile, error) {
	files, err := os.ReadDir(migrationFilesDirectoryPath)
	if err != nil {
		return nil, err
	}

	var migrationFiles []migrationFile

	for _, file := range files {
		if filepath.Ext(file.Name()) == ".sql" {
			filePath := filepath.Join(migrationFilesDirectoryPath, file.Name())

			content, err := os.ReadFile(filePath)
			if err != nil {
				log.Printf("failed to read file %s: %v", filePath, err)
				continue
			}

			migrationFiles = append(migrationFiles, *(&migrationFile{
				Filename: file.Name(),
				SQL:      string(content),
			}))
		}
	}
	return migrationFiles, nil
}

// getMigrationsInDB will look in the db to see which .sql files have already been stored.
func getMigrationsInDB(db *pgx.Conn, migrationTableName string) ([]string, error) {
	sql := fmt.Sprintf(`
		SELECT filename 
			FROM public.%s
		ORDER BY created_at ASC 
	`, migrationTableName)
	rows, err := db.Query(context.Background(), sql)
	if err != nil {
		return nil, err
	}

	var filenames []string

	for rows.Next() {
		var value string
		if err := rows.Scan(&value); err != nil {
			log.Fatalf("Failed to scan row: %v", err)
		}
		filenames = append(filenames, value)
	}

	return filenames, nil
}

// compareMigrationsToRun will compare the list of files to the migrations found in the db to see which files need to be run.
// Returns only the filtered diff slice.
func compareMigrationsToRun(migrationFiles []migrationFile, migrationsInDB []string) []migrationFile {
	var migrationsToRun []migrationFile

	for _, migration := range migrationFiles {
		found := false
		for _, migrationsInDBName := range migrationsInDB {
			if migration.Filename == migrationsInDBName {
				found = true
			}
		}
		if !found {
			migrationsToRun = append(migrationsToRun, migration)
		}
	}
	return migrationsToRun
}

// performMigrations will actually take the files that need to be run and execute them on the db server
// Additionally, it will update the migration history table with the list of files so they won't be processed on the next run.
func performMigrations(migrations []migrationFile, db *pgx.Conn, migrationTableName string, verbose bool) error {
	for _, migration := range migrations {

		if verbose {
			fmt.Println(migration.SQL)
		}

		_, err := db.Exec(context.Background(), migration.SQL)
		if err != nil {
			return err
		} else {
			sql := fmt.Sprintf(`
				INSERT INTO public.%s (
					filename
				) 
				VALUES ($1)
		`, migrationTableName)
			_, err = db.Exec(context.Background(), sql, migration.Filename)
			if err != nil {
				return err
			}
		}
	}
	return nil
}
